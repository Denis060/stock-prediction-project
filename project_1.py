# -*- coding: utf-8 -*-
"""Project_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pWKuS-sjemZFgS3w1E8cKAzMPr3zM9y5
"""

import yfinance as yf
import pandas as pd

data=yf.download("AAPL",start="2017-01-01",end="2023-01-01")

print(data.head())

import numpy as np

data.info()

data.isnull().sum()

#Creating the target variable
data['Target']=np.where(data['Close'].shift(-1)>data['Close'],1,1)

data[['Close','Target']].head()

#calculation of daily returns
data['Daily_Return'] = data['Close'].pct_change()

#calculation of 10-day and 50-day moving averages of the clsoing price
data['MA_10'] = data['Close'].rolling(window=10).mean()
data['MA_50'] = data['Close'].rolling(window=50).mean()

#calculation of 10-day volatility ( standard deviation of daily returns)
data['Volatility_10'] = data['Daily_Return'].rolling(window=10).std()

#calculation of 10-day moving average of volume
data['Volume_MA_10'] = data['Volume'].rolling(window=10).mean()

data.head()

data.isnull().sum()

#dropping the null values after the calculation
data.dropna(inplace=True)

data.head()

data.isnull().sum()

#importing the visualization libraries
import matplotlib.pyplot as plt
import seaborn as sns



#Visualiing Key Variables
#Visualising Closing price Over Time
plt.figure(figsize=(12,6))
plt.plot(data.index,data['Close'],label='Close Price')
plt.title('Close Price Over Time')
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.legend()
plt.show()

#10 Day vs 50 Day Moving Averages
plt.figure(figsize=(12,6))
plt.plot(data.index,data['Close'],label='Close Price', color='orange', alpha=0.5)
plt.plot(data.index,data['MA_10'],label='10 Day MA', color='blue')
plt.plot(data.index,data['MA_50'],label='50 Day MA', color='red')
plt.title('10 Day vs 50 Day Moving Averages')
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.legend()
plt.show()

#Daily Returns Histogram
plt.figure(figsize=(12,6))
plt.plot(data.index,data['Volume'], color='blue')
plt.title('Trading Volume Over Time')
plt.xlabel('Date')
plt.ylabel('Volume')
plt.show()

#Defining feature variable (X) and target variable(y)
X=data[['Close','Volume','MA_10','MA_50','Volatility_10','Volume_MA_10','Daily_Return']]
y=data['Target']

print(X.head())
print(y.head())

from sklearn.model_selection import train_test_split
X_train,X_test,y_train,y_test=train_test_split(X,y, test_size=0.2, random_state=42)

print("The shape of the Train Feautures are: ",X_train.shape)
print("The shape of the Test Feautures are: ",X_test.shape)
print("The shape of the Train Label are: ",y_train.shape)
print("The shape of the Test Label are: ",y_test.shape)

from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

#creating a dictionary of the models
models={
    'Decision Tree':DecisionTreeClassifier(),
    'K-Nearest Neighbors':KNeighborsClassifier()
}

# an empty disctionary to store the accuray of the models
model_accuracy={}

for model_name, model in models.items():

  #fitting the models
    model.fit(X_train,y_train)

    #Making predictions on the model
    y_pred=model.predict(X_test)

    #calculating the accuracy of the model
    accuracy=accuracy_score(y_test,y_pred)

    #storing the accuracy in the dictionary
    model_accuracy[model_name]=accuracy

    print(f'{model_name} Classifier Accuracy: {accuracy * 100:.2f}%')

best_model=max(model_accuracy,key=model_accuracy.get)
print(f'\nThe best model is {best_model} with an accuracy of {model_accuracy[best_model] * 100:.2f}%')

"""All the models shows 100% accuracy. So in order for us to determine the best model, we have to look at the  execution speed, because efficiency is key.


Decision Tree is faster for prediction with large datasets, K-Nearest Neighbour on the other hand can be slower in prediction as it has to to calculate the distance to all points in the training set. Making it not suitable  for large datasets.
However, based on robustness and interpretability through cross validation and efficiency,   **DECISION TREE**   is often prefered. Therefore, It's the **Best Model**



"""